"""Amoisekai â€” Combat Engine.

Deterministic Resolution Combat system. No traditional HP-trading;
combat is resolved via a composite score that determines narrative outcome.

The Writer agent receives a CombatBrief and writes combat prose accordingly.
No AI/LLM calls happen in this module â€” pure deterministic math.

Ref: COMBAT_SYSTEM_SPEC v2.0, POWER_SYSTEM_SPEC Â§4-5
"""

from __future__ import annotations

import random
from enum import Enum

from pydantic import BaseModel, Field

from app.models.power import (
    CombatMetrics,
    Intensity,
    NormalSkill,
    Principle,
    ResonanceState,
    get_principle_interaction,
)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Combat Outcome
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class CombatOutcome(str, Enum):
    """Three-tier outcome from combat resolution."""

    FAVORABLE = "favorable"      # Score â‰¥ 0.60 â€” player wins decisively
    MIXED = "mixed"              # 0.40 â‰¤ score < 0.60 â€” partial success
    UNFAVORABLE = "unfavorable"  # Score < 0.40 â€” player takes losses

    @property
    def narrative_instruction(self) -> str:
        instructions = {
            "favorable": (
                "Player wins clearly. Describe skill mastery and decisive action. "
                "Enemy is outmatched. Minimal cost to player."
            ),
            "mixed": (
                "Uncertain battle. Player achieves objective but takes damage or "
                "makes costly trade-offs. Show struggle and resourcefulness."
            ),
            "unfavorable": (
                "Player is overwhelmed. Must retreat, suffer injury, or lose something. "
                "Show desperation. May gain insight or ally from the loss."
            ),
        }
        return instructions[self.value]


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Enemy Profile (minimal for Resolution Combat)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class EnemyProfile(BaseModel):
    """Minimal enemy data needed for combat score.

    Generated by Planner when creating a combat beat.
    """

    name: str = "Unknown Enemy"
    principle: str = ""          # Primary principle (Principle enum value)
    threat_level: float = 0.5   # 0.0-1.0, relative to player's rank
    description: str = ""        # For Writer context
    weakness_hint: str = ""      # For narrative flavor


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Combat Brief (Writer context)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class CombatBrief(BaseModel):
    """Structured combat data passed to SceneWriter.

    Contains everything Writer needs to describe combat narratively
    without making any mechanical decisions.
    """

    # Participants
    player_skill_name: str = ""
    player_skill_mechanic: str = ""
    player_principle: str = ""
    enemy_name: str = ""
    enemy_description: str = ""
    enemy_principle: str = ""

    # Resolution
    combat_score: float = 0.5
    outcome: str = "mixed"           # CombatOutcome value
    outcome_instruction: str = ""

    # Context for prose
    principle_advantage: str = ""    # "strong" | "weak" | "neutral" | "synergy"
    advantage_description: str = ""  # "Energy overwhelms Void" etc.
    intensity: str = "safe"          # Intensity value
    backlash_triggered: bool = False
    backlash_description: str = ""

    # Post-combat state changes
    stability_cost: float = 0.0
    hp_cost: float = 0.0
    resonance_growth: float = 0.0    # How much resonance grew
    resonance_principle: str = ""    # Which principle grew

    # Unique skill involvement
    unique_skill_active: bool = False
    unique_skill_name: str = ""
    unique_skill_mechanic: str = ""
    unique_skill_outcome: str = "full"   # SkillOutcome value
    unique_skill_narrative: str = ""     # Writer instruction for outcome
    unique_skill_context: dict = Field(default_factory=dict)  # V2 rich context

    # Suppression state (CONTROL_SYSTEM v1 integration)
    suppression_level: str = "none"       # SuppressionLevel value
    suppression_modifier: float = 1.0     # Effectiveness modifier (0.0-1.0)
    suppression_narrative: str = ""       # Writer instruction for suppression

    # Weapon context (WEAPON_SYSTEM_SPEC v1.0)
    weapon_context: dict = Field(default_factory=dict)  # Weapon data for Writer


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Combat Score Computation
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Weight distribution (must sum to 1.0)
W_BUILD_FIT = 0.45       # Resonance + principle advantage
W_PLAYER_SKILL = 0.30    # DQS + stability
W_ENVIRONMENT = 0.15     # Floor bonus + intensity
W_RANDOMNESS = 0.10      # CRNG + unique skill bonus

# Sub-weights within each category
W_RESONANCE = 0.25
W_PRINCIPLE_ADV = 0.20
W_DQS = 0.20
W_STABILITY = 0.10
W_FLOOR = 0.10
W_INTENSITY = 0.05
W_CRNG = 0.05
W_UNIQUE = 0.05


def compute_combat_score(
    resonance: ResonanceState,
    metrics: CombatMetrics,
    skill: NormalSkill,
    enemy: EnemyProfile,
    floor: int = 1,
    intensity: Intensity = Intensity.SAFE,
    crng_roll: float = 0.5,
    unique_skill_bonus: float = 0.0,
    weapon_bonus: float = 0.0,
    weapon_playerskill_bonus: float = 0.0,
    signature_move_bonus: float = 0.0,
) -> float:
    """Compute deterministic combat score (0.0-1.0).

    Uses the 4-component weighted formula from COMBAT_SYSTEM_SPEC v2.0:
    - Build Fit (45%): resonance alignment + principle advantage + weapon grade
    - Player Skill (30%): DQS mastery + stability resource
    - Environment (15%): floor familiarity + intensity bonus
    - Controlled Randomness (10%): CRNG variance + unique skill

    Args:
        resonance: Player's per-principle resonance state
        metrics: Current HP, stability, DQS, breakthrough
        skill: The NormalSkill being used
        enemy: Enemy profile with principle and threat
        floor: Current tower floor (1-5)
        intensity: Combat intensity level
        crng_roll: CRNG result (0.0-1.0)
        unique_skill_bonus: Bonus from unique skill activation (0.0-0.08)
        weapon_bonus: Flat additive to BuildFit from weapon grade (0.0-0.20)
        weapon_playerskill_bonus: Flat additive to PlayerSkill from Soul-Link (0.0-0.03)
        signature_move_bonus: Flat additive to BuildFit from Signature Move (+0.05/0.07/0.10)

    Returns:
        Combat score clamped to 0.0-1.0
    """
    # â”€â”€ Build Fit (45%) â”€â”€
    # Average resonance across skill's principles
    skill_resonance = 0.0
    if skill.principles:
        total = sum(resonance.get(p) for p in skill.principles)
        skill_resonance = total / len(skill.principles)

    # Principle interaction
    interaction = get_principle_interaction(
        skill.primary_principle or "order",
        enemy.principle or "order",
    )
    # Normalize advantage_mod from [-0.10, +0.15] to [0.0, 1.0]
    adv_normalized = (interaction.advantage_mod + 0.10) / 0.25

    build_fit = (
        skill_resonance * (W_RESONANCE / W_BUILD_FIT)
        + adv_normalized * (W_PRINCIPLE_ADV / W_BUILD_FIT)
    )

    # Weapon grade bonus (WEAPON_SYSTEM_SPEC Â§9)
    build_fit += weapon_bonus

    # Signature Move burst (WEAPON_SYSTEM_SPEC Â§7: +0.05 per encounter)
    build_fit += signature_move_bonus

    # â”€â”€ Player Skill (30%) â”€â”€
    player_skill = (
        metrics.dqs_ratio * (W_DQS / W_PLAYER_SKILL)
        + metrics.stability_ratio * (W_STABILITY / W_PLAYER_SKILL)
    )

    # Weapon Soul-Link bonus (WEAPON_SYSTEM_SPEC Â§9: +0.02 flat after DQS+Stability)
    player_skill += weapon_playerskill_bonus

    # â”€â”€ Environment (15%) â”€â”€
    # Floor familiarity: higher floor = player is more experienced
    floor_bonus = min(1.0, floor / 5.0)
    env = (
        floor_bonus * (W_FLOOR / W_ENVIRONMENT)
        + intensity.bonus / 0.05 * (W_INTENSITY / W_ENVIRONMENT)
    )

    # â”€â”€ Controlled Randomness (10%) â”€â”€
    crng_component = (
        crng_roll * (W_CRNG / W_RANDOMNESS)
        + min(1.0, unique_skill_bonus / 0.08) * (W_UNIQUE / W_RANDOMNESS)
    )

    # â”€â”€ Weighted sum â”€â”€
    raw_score = (
        build_fit * W_BUILD_FIT
        + player_skill * W_PLAYER_SKILL
        + env * W_ENVIRONMENT
        + crng_component * W_RANDOMNESS
    )

    # Adjust by enemy threat: higher threat â†’ harder
    threat_penalty = enemy.threat_level * 0.15
    final_score = raw_score - threat_penalty + 0.075  # Center around 0.5

    return max(0.0, min(1.0, final_score))


def resolve_combat(combat_score: float) -> CombatOutcome:
    """Resolve combat score into narrative outcome.

    Thresholds:
        â‰¥ 0.60 â†’ FAVORABLE
        0.40 â€“ 0.59 â†’ MIXED
        < 0.40 â†’ UNFAVORABLE
    """
    if combat_score >= 0.60:
        return CombatOutcome.FAVORABLE
    elif combat_score >= 0.40:
        return CombatOutcome.MIXED
    else:
        return CombatOutcome.UNFAVORABLE


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Post-Combat Effects
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Stability cost by intensity
STABILITY_COST = {
    "safe": 5.0,
    "push": 15.0,
    "overdrive": 30.0,
}

# HP costs by outcome
HP_COST = {
    "favorable": 0.0,
    "mixed": 10.0,
    "unfavorable": 25.0,
}

# Resonance growth per combat (skill's primary principle)
RESONANCE_GROWTH = {
    "favorable": 0.03,
    "mixed": 0.02,
    "unfavorable": 0.01,
}


def check_backlash(intensity: Intensity) -> bool:
    """Roll for backlash at given intensity.

    Overdrive has 20% chance, Push has 5%, Safe has 0%.
    """
    if intensity.backlash_risk <= 0:
        return False
    return random.random() < intensity.backlash_risk


def apply_combat_results(
    metrics: CombatMetrics,
    resonance: ResonanceState,
    outcome: CombatOutcome,
    intensity: Intensity,
    skill: NormalSkill,
    floor: int = 1,
    backlash: bool = False,
    personal_cap_bonus: float = 0.0,
) -> dict:
    """Apply post-combat effects to metrics and resonance.

    Returns dict summary of changes for logging/display.
    """
    # Stability cost
    stab_cost = STABILITY_COST.get(intensity.value, 5.0)
    if backlash:
        stab_cost *= 1.5  # Backlash = 50% extra stability loss

    metrics.stability = max(0.0, metrics.stability - stab_cost)

    # HP cost
    hp_cost = HP_COST.get(outcome.value, 0.0)
    if backlash:
        hp_cost += 10.0  # Backlash = extra HP damage

    metrics.hp = max(0.0, metrics.hp - hp_cost)

    # Resonance growth on primary principle
    growth = RESONANCE_GROWTH.get(outcome.value, 0.01)
    grown_principle = skill.primary_principle
    new_resonance = 0.0
    if grown_principle:
        new_resonance = resonance.grow(
            grown_principle, growth,
            floor=floor,
            personal_cap_bonus=personal_cap_bonus,
        )

    # Instability change
    instability_delta = 0.0
    if backlash:
        instability_delta = 5.0
    elif outcome == CombatOutcome.UNFAVORABLE:
        instability_delta = 3.0
    elif outcome == CombatOutcome.FAVORABLE:
        instability_delta = -1.0

    metrics.instability = max(
        0.0, min(100.0, metrics.instability + instability_delta)
    )

    return {
        "stability_cost": stab_cost,
        "hp_cost": hp_cost,
        "resonance_growth": growth,
        "resonance_principle": grown_principle,
        "new_resonance": new_resonance,
        "instability_delta": instability_delta,
        "backlash": backlash,
    }


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Build Combat Brief (for Writer)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def build_combat_brief(
    resonance: ResonanceState,
    metrics: CombatMetrics,
    skill: NormalSkill,
    enemy: EnemyProfile,
    floor: int = 1,
    intensity: Intensity = Intensity.SAFE,
    crng_roll: float = 0.5,
    unique_skill_bonus: float = 0.0,
    unique_skill_name: str = "",
    unique_skill_mechanic: str = "",
    unique_skill_outcome: str = "full",
    unique_skill_narrative: str = "",
    personal_cap_bonus: float = 0.0,
    suppression_level: str = "none",
    suppression_modifier: float = 1.0,
    suppression_narrative: str = "",
    weapon_bonus: float = 0.0,
    weapon_playerskill_bonus: float = 0.0,
    weapon_context: dict | None = None,
    signature_move_bonus: float = 0.0,
) -> CombatBrief:
    """Run full combat resolution and build a CombatBrief for the Writer.

    This is the main entry point: one call does score â†’ outcome â†’ effects â†’ brief.
    """
    # 1. Apply suppression to unique skill bonus
    effective_unique_bonus = unique_skill_bonus * suppression_modifier

    # 1b. Compute score
    score = compute_combat_score(
        resonance=resonance,
        metrics=metrics,
        skill=skill,
        enemy=enemy,
        floor=floor,
        intensity=intensity,
        crng_roll=crng_roll,
        unique_skill_bonus=effective_unique_bonus,
        weapon_bonus=weapon_bonus,
        weapon_playerskill_bonus=weapon_playerskill_bonus,
        signature_move_bonus=signature_move_bonus,
    )

    # 2. Resolve outcome
    outcome = resolve_combat(score)

    # 3. Check backlash
    backlash = check_backlash(intensity)

    # 4. Apply effects (mutates metrics and resonance)
    effects = apply_combat_results(
        metrics=metrics,
        resonance=resonance,
        outcome=outcome,
        intensity=intensity,
        skill=skill,
        floor=floor,
        backlash=backlash,
        personal_cap_bonus=personal_cap_bonus,
    )

    # 5. Build principle advantage description
    interaction = get_principle_interaction(
        skill.primary_principle or "order",
        enemy.principle or "order",
    )
    adv_descriptions = {
        "strong": (
            f"{Principle(skill.primary_principle).display_name} "
            f"overwhelms {Principle(enemy.principle).display_name}"
        ),
        "weak": (
            f"{Principle(skill.primary_principle).display_name} "
            f"struggles against {Principle(enemy.principle).display_name}"
        ),
        "synergy": (
            f"{Principle(skill.primary_principle).display_name} "
            f"resonates with {Principle(enemy.principle).display_name}"
        ),
        "neutral": "No elemental advantage",
    }

    backlash_desc = ""
    if backlash:
        backlash_desc = (
            f"Power backlash! {intensity.value.title()} intensity "
            f"caused {effects['stability_cost']:.0f} stability loss "
            f"and {effects['hp_cost']:.0f} HP damage."
        )

    return CombatBrief(
        # Participants
        player_skill_name=skill.name,
        player_skill_mechanic=skill.mechanic,
        player_principle=skill.primary_principle,
        enemy_name=enemy.name,
        enemy_description=enemy.description,
        enemy_principle=enemy.principle,
        # Resolution
        combat_score=round(score, 3),
        outcome=outcome.value,
        outcome_instruction=outcome.narrative_instruction,
        # Context
        principle_advantage=interaction.interaction.value,
        advantage_description=adv_descriptions.get(
            interaction.interaction.value, ""
        ),
        intensity=intensity.value,
        backlash_triggered=backlash,
        backlash_description=backlash_desc,
        # Post-combat
        stability_cost=effects["stability_cost"],
        hp_cost=effects["hp_cost"],
        resonance_growth=effects["resonance_growth"],
        resonance_principle=effects["resonance_principle"] or "",
        # Unique skill
        unique_skill_active=effective_unique_bonus > 0,
        unique_skill_name=unique_skill_name,
        unique_skill_mechanic=unique_skill_mechanic,
        unique_skill_outcome=unique_skill_outcome,
        unique_skill_narrative=unique_skill_narrative,
        # Suppression
        suppression_level=suppression_level,
        suppression_modifier=suppression_modifier,
        suppression_narrative=suppression_narrative,
        # Weapon
        weapon_context=weapon_context or {},
    )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Phase B â€” Multi-Phase Combat Engine
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# Ref: COMBAT_SYSTEM_SPEC v1.1 Â§6
#
# The Resolution Combat model resolves combat in phases.
# Each phase uses compute_combat_score() with action-specific modifiers.
# Between phases, the player makes a decision (action + intensity).

from app.models.combat import (
    CombatAction,
    CombatApproach,
    CombatBriefV2,
    CombatResult,
    DecisionPoint,
    DecisionPointChoice,
    EncounterType,
    FloorModifier,
    BossPhase,
    BossTemplate,
    PhaseResult,
    StabilityTier,
)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Action Modifiers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Combat score modifier per action type
ACTION_SCORE_MODIFIER: dict[str, float] = {
    "strike": 0.0,        # Baseline â€” pure damage
    "shift": -0.03,       # Slight score penalty but enables vector adapt
    "stabilize": -0.08,   # Lower damage but recovers stability
}

# Stability recovery amount for Stabilize action
STABILIZE_RECOVERY = {
    "safe": 15.0,
    "push": 10.0,
    "overdrive": 5.0,   # Overdrive stabilize = risky but possible
}

# Enemy stability damage multiplier per action
ENEMY_STABILITY_DAMAGE = {
    "strike": 1.0,        # Full stability pressure on enemy
    "shift": 0.3,         # Minimal pressure
    "stabilize": 0.0,     # No pressure (defensive)
}

# Structural damage multiplier per action
STRUCTURAL_DAMAGE = {
    "strike": 1.0,         # Full damage
    "shift": 0.4,          # Some damage while adapting
    "stabilize": 0.0,      # No damage (defensive)
}


def get_stability_tier(stability: float) -> StabilityTier:
    """Get current stability tier from value."""
    return StabilityTier.from_value(stability)


def apply_stability_tier_effects(
    tier: StabilityTier,
    intensity: Intensity,
    crng_roll: float = 0.5,
) -> dict:
    """Apply stability tier effects to combat parameters.

    Returns dict with modifiers to apply to combat resolution:
    - score_modifier: added to combat score
    - overdrive_blocked: True if overdrive is disabled
    - misfire: True if skill misfires this phase
    - effective_intensity: downgraded intensity if overdrive blocked
    """
    effects = tier.effects
    misfire = crng_roll < effects["misfire_chance"]

    effective_intensity = intensity
    overdrive_blocked = False
    if intensity == Intensity.OVERDRIVE and not effects["overdrive_available"]:
        effective_intensity = Intensity.PUSH  # Downgrade
        overdrive_blocked = True

    return {
        "score_modifier": effects["combat_score_modifier"],
        "overdrive_blocked": overdrive_blocked,
        "misfire": misfire,
        "effective_intensity": effective_intensity,
        "description": effects["description"],
    }


def apply_floor_modifier(
    base_score: float,
    skill: NormalSkill,
    enemy_principle: str,
    floor_mod: FloorModifier | None,
) -> float:
    """Apply floor/environment modifiers to combat score."""
    if not floor_mod:
        return base_score

    # Buff player's principle
    player_buff = floor_mod.get_modifier(skill.primary_principle or "")
    # Nerf enemy's principle (negative = penalty for enemy = bonus for player)
    enemy_nerf = -floor_mod.get_modifier(enemy_principle)

    return base_score + player_buff + enemy_nerf


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Action Handlers
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def compute_strike_effects(
    combat_score: float,
    outcome: CombatOutcome,
    intensity: Intensity,
    enemy_hp: float,
    enemy_stability: float,
    backlash: bool = False,
) -> dict:
    """Compute Strike action effects on enemy.

    Strike = primary damage dealer. Deals structural + stability damage.
    """
    # Base damage scales with combat score
    base_damage = 15.0 + (combat_score * 20.0)  # 15-35 damage range

    # Intensity multiplier
    intensity_mult = {"safe": 0.8, "push": 1.0, "overdrive": 1.4}
    mult = intensity_mult.get(intensity.value, 1.0)

    structural_damage = base_damage * mult * STRUCTURAL_DAMAGE["strike"]
    stability_damage = (base_damage * 0.6) * mult * ENEMY_STABILITY_DAMAGE["strike"]

    if outcome == CombatOutcome.UNFAVORABLE:
        structural_damage *= 0.4
        stability_damage *= 0.5

    return {
        "structural_damage": round(structural_damage, 1),
        "stability_damage": round(stability_damage, 1),
        "enemy_hp_after": max(0.0, enemy_hp - structural_damage),
        "enemy_stability_after": max(0.0, enemy_stability - stability_damage),
    }


def compute_shift_effects(
    combat_score: float,
    outcome: CombatOutcome,
    intensity: Intensity,
    enemy_hp: float,
    enemy_stability: float,
    boss_phase: BossPhase | None = None,
) -> dict:
    """Compute Shift action effects.

    Shift = adapt principle vector. Less damage but counters phase shifts.
    Bonus: if boss just shifted phases, Shift gives combat score buff next phase.
    """
    base_damage = 15.0 + (combat_score * 20.0)
    intensity_mult = {"safe": 0.8, "push": 1.0, "overdrive": 1.3}
    mult = intensity_mult.get(intensity.value, 1.0)

    structural_damage = base_damage * mult * STRUCTURAL_DAMAGE["shift"]
    stability_damage = (base_damage * 0.6) * mult * ENEMY_STABILITY_DAMAGE["shift"]

    # Shift bonus: combat_score buff for next phase
    adapt_bonus = 0.05  # Base adaptation benefit
    if boss_phase and boss_phase.phase_number > 1:
        adapt_bonus = 0.10  # Double bonus when countering phase shift

    return {
        "structural_damage": round(structural_damage, 1),
        "stability_damage": round(stability_damage, 1),
        "enemy_hp_after": max(0.0, enemy_hp - structural_damage),
        "enemy_stability_after": max(0.0, enemy_stability - stability_damage),
        "adapt_bonus_next_phase": adapt_bonus,
    }


def compute_stabilize_effects(
    intensity: Intensity,
    player_stability: float,
    player_instability: float,
) -> dict:
    """Compute Stabilize action effects.

    Stabilize = recover stability, reduce instability. No damage to enemy.
    """
    recovery = STABILIZE_RECOVERY.get(intensity.value, 10.0)
    new_stability = min(100.0, player_stability + recovery)
    instability_reduction = 2.0 if intensity == Intensity.SAFE else 1.0

    return {
        "structural_damage": 0.0,
        "stability_damage": 0.0,
        "stability_recovered": round(new_stability - player_stability, 1),
        "player_stability_after": new_stability,
        "instability_reduction": instability_reduction,
        "player_instability_after": max(0.0, player_instability - instability_reduction),
    }


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Phase Resolution
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def resolve_combat_phase(
    resonance: ResonanceState,
    metrics: CombatMetrics,
    skill: NormalSkill,
    enemy: EnemyProfile,
    action: CombatAction = CombatAction.STRIKE,
    intensity: Intensity = Intensity.SAFE,
    floor: int = 1,
    crng_roll: float = 0.5,
    unique_skill_bonus: float = 0.0,
    floor_modifier: FloorModifier | None = None,
    boss_phase: BossPhase | None = None,
    adapt_bonus: float = 0.0,
    phase_number: int = 1,
    enemy_hp: float = 100.0,
    enemy_stability: float = 100.0,
) -> PhaseResult:
    """Resolve a single combat phase.

    Uses existing compute_combat_score() with action-specific modifiers,
    stability tier effects, and floor modifiers.

    Args:
        resonance: Player's resonance state
        metrics: Player's combat metrics (HP, stability, etc.)
        skill: Equipped skill
        enemy: Enemy profile
        action: Player's chosen action (Strike/Shift/Stabilize)
        intensity: Chosen intensity (Safe/Push/Overdrive)
        floor: Current floor
        crng_roll: Randomness factor
        unique_skill_bonus: Active unique skill bonus
        floor_modifier: Environment modifiers for this location
        boss_phase: Boss phase data (if boss encounter)
        adapt_bonus: Carry-over bonus from previous Shift action
        phase_number: Current phase number (1-indexed)
        enemy_hp: Enemy's current HP
        enemy_stability: Enemy's current stability

    Returns:
        PhaseResult with all computed data for Writer.
    """
    narrative_cues: list[str] = []

    # â”€â”€ 1. Stability tier effects â”€â”€
    player_tier = get_stability_tier(metrics.stability)
    tier_effects = apply_stability_tier_effects(player_tier, intensity, crng_roll)
    effective_intensity = tier_effects["effective_intensity"]

    if tier_effects["overdrive_blocked"]:
        narrative_cues.append(
            f"Stability quÃ¡ tháº¥p ({player_tier.value}) â€” Overdrive bá»‹ khÃ³a, "
            f"háº¡ xuá»‘ng {effective_intensity.value}"
        )

    if tier_effects["misfire"]:
        narrative_cues.append(
            f"Stability báº¥t á»•n â€” ká»¹ nÄƒng bá»‹ nhiá»…u ({player_tier.value})"
        )

    # â”€â”€ 2. Compute base combat score â”€â”€
    base_score = compute_combat_score(
        resonance=resonance,
        metrics=metrics,
        skill=skill,
        enemy=enemy,
        floor=floor,
        intensity=effective_intensity,
        crng_roll=crng_roll,
        unique_skill_bonus=unique_skill_bonus,
    )

    # â”€â”€ 3. Apply modifiers â”€â”€
    # Action modifier
    action_mod = ACTION_SCORE_MODIFIER.get(action.value, 0.0)

    # Stability tier modifier
    tier_mod = tier_effects["score_modifier"]

    # Misfire penalty
    misfire_mod = -0.15 if tier_effects["misfire"] else 0.0

    # Floor environment modifier
    modified_score = apply_floor_modifier(
        base_score + action_mod + tier_mod + misfire_mod + adapt_bonus,
        skill, enemy.principle, floor_modifier,
    )

    # Boss phase resistance/weakness
    if boss_phase:
        boss_principle = boss_phase.dominant_principle
        if boss_principle and boss_principle == skill.primary_principle:
            modified_score -= 0.05  # Resistance penalty (same principle)
            narrative_cues.append(
                f"Enemy pháº£n khÃ¡ng {boss_principle} â€” hiá»‡u quáº£ giáº£m"
            )

    final_score = max(0.0, min(1.0, modified_score))

    # â”€â”€ 4. Resolve outcome â”€â”€
    outcome = resolve_combat(final_score)

    # â”€â”€ 5. Check backlash â”€â”€
    backlash = check_backlash(effective_intensity)
    backlash_desc = ""
    if backlash:
        backlash_desc = (
            f"Backlash! {effective_intensity.value.title()} gÃ¢y pháº£n á»©ng ngÆ°á»£c"
        )
        narrative_cues.append(backlash_desc)

    # â”€â”€ 6. Apply player costs â”€â”€
    effects = apply_combat_results(
        metrics=metrics,
        resonance=resonance,
        outcome=outcome,
        intensity=effective_intensity,
        skill=skill,
        floor=floor,
        backlash=backlash,
    )

    # â”€â”€ 7. Action-specific effects â”€â”€
    action_effects: dict = {}

    if action == CombatAction.STRIKE:
        action_effects = compute_strike_effects(
            combat_score=final_score,
            outcome=outcome,
            intensity=effective_intensity,
            enemy_hp=enemy_hp,
            enemy_stability=enemy_stability,
            backlash=backlash,
        )
        narrative_cues.append(
            f"Strike â€” {action_effects['structural_damage']:.0f} damage, "
            f"{action_effects['stability_damage']:.0f} stability pressure"
        )

    elif action == CombatAction.SHIFT:
        action_effects = compute_shift_effects(
            combat_score=final_score,
            outcome=outcome,
            intensity=effective_intensity,
            enemy_hp=enemy_hp,
            enemy_stability=enemy_stability,
            boss_phase=boss_phase,
        )
        narrative_cues.append(
            f"Shift â€” adapt vector, "
            f"next phase +{action_effects.get('adapt_bonus_next_phase', 0):.2f} score"
        )

    elif action == CombatAction.STABILIZE:
        action_effects = compute_stabilize_effects(
            intensity=effective_intensity,
            player_stability=metrics.stability,
            player_instability=metrics.instability,
        )
        # Apply stabilize recovery to player
        metrics.stability = action_effects["player_stability_after"]
        metrics.instability = action_effects["player_instability_after"]
        narrative_cues.append(
            f"Stabilize â€” há»“i phá»¥c {action_effects['stability_recovered']:.0f} stability"
        )
        # No damage to enemy
        action_effects["enemy_hp_after"] = enemy_hp
        action_effects["enemy_stability_after"] = enemy_stability

    # â”€â”€ 8. Determine phase shift for boss â”€â”€
    phase_shifted = False
    boss_tell_for_next = ""
    new_enemy_hp = action_effects.get("enemy_hp_after", enemy_hp)

    if boss_phase and len(boss_phase.name) > 0:
        if boss_phase.tell_pattern:
            boss_tell_for_next = boss_phase.tell_pattern

    # â”€â”€ 9. Adapt bonus carry-over â”€â”€
    phase_adapt_bonus = 0.0
    if action == CombatAction.SHIFT:
        phase_adapt_bonus = action_effects.get("adapt_bonus_next_phase", 0.05)

    # â”€â”€ 10. Unique skill narration â”€â”€
    skill_activated = unique_skill_bonus > 0
    skill_desc = ""
    if skill_activated:
        skill_desc = f"Unique skill active â€” bonus {unique_skill_bonus:.2f}"
        narrative_cues.append(skill_desc)

    # â”€â”€ 11. Build PhaseResult â”€â”€
    return PhaseResult(
        phase_number=phase_number,
        outcome=outcome.value,
        combat_score=round(final_score, 3),
        action_taken=action.value,
        intensity_used=effective_intensity.value,
        structural_damage_dealt=action_effects.get("structural_damage", 0.0),
        stability_damage_dealt=action_effects.get("stability_damage", 0.0),
        player_hp_remaining=round(metrics.hp, 1),
        player_stability_remaining=round(metrics.stability, 1),
        enemy_hp_remaining=round(action_effects.get("enemy_hp_after", enemy_hp), 1),
        enemy_stability_remaining=round(
            action_effects.get("enemy_stability_after", enemy_stability), 1
        ),
        backlash_occurred=backlash,
        backlash_description=backlash_desc,
        phase_shifted=phase_shifted,
        skill_activated=skill_activated,
        skill_activation_description=skill_desc,
        stability_tier_changed=(
            get_stability_tier(metrics.stability) != player_tier
        ),
        adapt_bonus_next_phase=phase_adapt_bonus,
        narrative_cues=narrative_cues,
        boss_tell_for_next=boss_tell_for_next,
    )


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Decision Point Generation
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def generate_decision_point(
    phase_after: int,
    player_stability: float,
    enemy_hp: float,
    enemy_stability: float,
    boss_phase: BossPhase | None = None,
) -> DecisionPoint:
    """Generate a decision point between combat phases.

    Creates 3 meaningful choices (one per action type) with varied
    intensity/risk levels based on current combat state.

    Â§6.2: Choices are diverse â€” one aggressive, one adaptive, one defensive.
    """
    player_tier = get_stability_tier(player_stability)
    boss_tell = boss_phase.tell_pattern if boss_phase else ""
    context_parts = []

    if boss_phase:
        context_parts.append(f"Boss chuyá»ƒn sang phase: {boss_phase.name}")
        if boss_phase.special_mechanic:
            context_parts.append(f"Äáº·c biá»‡t: {boss_phase.special_mechanic}")

    if player_tier == StabilityTier.CRITICAL:
        context_parts.append("âš ï¸ Stability nguy hiá»ƒm â€” cÃ¢n nháº¯c Stabilize")
    elif player_tier == StabilityTier.BROKEN:
        context_parts.append("ğŸ”´ Stability sá»¥p Ä‘á»• â€” cáº§n Stabilize kháº©n cáº¥p")

    if enemy_hp < 30:
        context_parts.append("Enemy yáº¿u â€” cÆ¡ há»™i káº¿t thÃºc")

    context = " | ".join(context_parts) if context_parts else "Chá»n hÃ nh Ä‘á»™ng tiáº¿p theo"

    # â”€â”€ Generate 3 diverse choices â”€â”€
    choices = []

    # Choice 1: Aggressive Strike
    strike_intensity = "overdrive" if enemy_hp < 40 else "push"
    strike_risk = 5 if strike_intensity == "overdrive" else 3
    if player_tier in (StabilityTier.CRITICAL, StabilityTier.BROKEN):
        strike_intensity = "push"  # Can't overdrive at low stability
        strike_risk = 4

    stability_after_strike = max(0, player_stability - STABILITY_COST.get(strike_intensity, 15))
    choices.append(DecisionPointChoice(
        action=CombatAction.STRIKE,
        intensity=strike_intensity,
        risk_level=strike_risk,
        hint=f"Táº¥n cÃ´ng {'toÃ n lá»±c' if strike_intensity == 'overdrive' else 'máº¡nh'}",
        stability_preview=f"Stability: {player_stability:.0f}% â†’ ~{stability_after_strike:.0f}%",
        boss_tell=boss_tell,
    ))

    # Choice 2: Adaptive Shift
    shift_intensity = "safe"
    shift_risk = 2
    shift_hint = "Thay Ä‘á»•i chiáº¿n thuáº­t, thÃ­ch á»©ng"
    if boss_phase and boss_phase.phase_number > 1:
        shift_hint = f"ThÃ­ch á»©ng vá»›i {boss_phase.dominant_principle} cá»§a boss"
        shift_risk = 2

    stability_after_shift = max(0, player_stability - STABILITY_COST.get(shift_intensity, 5))
    choices.append(DecisionPointChoice(
        action=CombatAction.SHIFT,
        intensity=shift_intensity,
        risk_level=shift_risk,
        hint=shift_hint,
        stability_preview=f"Stability: {player_stability:.0f}% â†’ ~{stability_after_shift:.0f}%",
        boss_tell=boss_tell,
    ))

    # Choice 3: Defensive Stabilize
    stabilize_recovery = STABILIZE_RECOVERY.get("safe", 15)
    stability_net = min(100, player_stability + stabilize_recovery - STABILITY_COST["safe"])
    stabilize_risk = 1
    stabilize_hint = "á»”n Ä‘á»‹nh, há»“i phá»¥c"
    if player_tier in (StabilityTier.CRITICAL, StabilityTier.BROKEN):
        stabilize_hint = "â€¼ï¸ á»”n Ä‘á»‹nh kháº©n cáº¥p â€” cáº§n há»“i phá»¥c NGAY"

    choices.append(DecisionPointChoice(
        action=CombatAction.STABILIZE,
        intensity="safe",
        risk_level=stabilize_risk,
        hint=stabilize_hint,
        stability_preview=f"Stability: {player_stability:.0f}% â†’ ~{stability_net:.0f}%",
        boss_tell=boss_tell,
    ))

    return DecisionPoint(
        phase_after=phase_after,
        context=context,
        choices=choices,
    )


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Full Encounter Orchestration
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def run_resolution_combat(
    resonance: ResonanceState,
    metrics: CombatMetrics,
    skill: NormalSkill,
    enemy: EnemyProfile,
    encounter_type: EncounterType = EncounterType.MINOR,
    floor: int = 1,
    crng_roll: float = 0.5,
    unique_skill_bonus: float = 0.0,
    floor_modifier: FloorModifier | None = None,
    boss_template: BossTemplate | None = None,
    player_decisions: list[CombatApproach] | None = None,
    fate_buffer: float = 0.0,
) -> CombatBriefV2:
    """Orchestrate a full multi-phase combat encounter.

    For Minor encounters: auto-resolve in 1 phase (Strike/Safe).
    For Duel/Boss: resolve phase by phase using player_decisions.

    If player_decisions is None or incomplete, auto-fill with Strike/Safe.
    Boss fights use boss_template for phase-specific mechanics.

    Args:
        resonance: Player's resonance (will be mutated)
        metrics: Player's combat metrics (will be mutated)
        skill: Equipped skill
        enemy: Enemy profile
        encounter_type: Minor/Duel/Boss/Climax
        floor: Current floor number
        crng_roll: Base CRNG (varied per phase)
        unique_skill_bonus: Unique skill bonus
        floor_modifier: Location-specific modifiers
        boss_template: Boss configuration (for Boss/Climax)
        player_decisions: Player's chosen action+intensity per phase

    Returns:
        CombatBriefV2 with all phase results and decision point data.
    """
    total_phases = encounter_type.phase_count
    decisions = player_decisions or []

    # Enemy state tracking
    enemy_hp = boss_template.base_hp if boss_template else 100.0
    enemy_stability = boss_template.base_stability if boss_template else 80.0

    # Results accumulation
    phase_results: list[PhaseResult] = []
    decision_points: list[DecisionPoint] = []
    adapt_bonus = 0.0  # Carry-over from Shift action
    total_stability_cost = 0.0
    total_hp_cost = 0.0
    fate_fired = False  # Mid-combat Fate Buffer save

    # Snapshot player state before combat
    initial_hp = metrics.hp
    initial_stability = metrics.stability
    initial_instability = metrics.instability

    # Principle interaction for brief
    interaction = get_principle_interaction(
        skill.primary_principle or "order",
        enemy.principle or "order",
    )

    for phase_idx in range(total_phases):
        phase_num = phase_idx + 1

        # â”€â”€ Get player decision for this phase â”€â”€
        if phase_idx < len(decisions):
            decision = decisions[phase_idx]
            action = decision.action
            intensity_str = decision.intensity
        else:
            # Auto-fill: Strike/Safe for missing decisions
            action = CombatAction.STRIKE
            intensity_str = "safe"

        try:
            intensity = Intensity(intensity_str)
        except ValueError:
            intensity = Intensity.SAFE

        # â”€â”€ Boss phase data â”€â”€
        boss_phase: BossPhase | None = None
        if boss_template:
            boss_phase = boss_template.get_phase(phase_num)
            # Apply boss resistances/weaknesses to enemy profile
            if boss_phase:
                # Adjust effective threat based on phase
                pressure_mult = {"low": 0.8, "medium": 1.0, "high": 1.2}
                adjusted_threat = enemy.threat_level * pressure_mult.get(
                    boss_phase.stability_pressure, 1.0
                )
                enemy = EnemyProfile(
                    name=enemy.name,
                    principle=boss_phase.dominant_principle,
                    threat_level=adjusted_threat,
                    description=enemy.description,
                    weakness_hint=enemy.weakness_hint,
                )

        # â”€â”€ Vary CRNG per phase â”€â”€
        phase_crng = (crng_roll + phase_idx * 0.17) % 1.0

        # â”€â”€ Resolve this phase â”€â”€
        phase_result = resolve_combat_phase(
            resonance=resonance,
            metrics=metrics,
            skill=skill,
            enemy=enemy,
            action=action,
            intensity=intensity,
            floor=floor,
            crng_roll=phase_crng,
            unique_skill_bonus=unique_skill_bonus,
            floor_modifier=floor_modifier,
            boss_phase=boss_phase,
            adapt_bonus=adapt_bonus,
            phase_number=phase_num,
            enemy_hp=enemy_hp,
            enemy_stability=enemy_stability,
        )

        phase_results.append(phase_result)

        # â”€â”€ Update enemy state â”€â”€
        enemy_hp = phase_result.enemy_hp_remaining
        enemy_stability = phase_result.enemy_stability_remaining

        # â”€â”€ Track adapt bonus for next phase (from PhaseResult) â”€â”€
        adapt_bonus = phase_result.adapt_bonus_next_phase

        # â”€â”€ Track cumulative costs â”€â”€
        total_stability_cost += STABILITY_COST.get(intensity.value, 5.0)
        total_hp_cost += HP_COST.get(phase_result.outcome, 0.0)

        # â”€â”€ Generate decision point (if not last phase) â”€â”€
        if phase_num < total_phases:
            next_boss_phase = None
            if boss_template:
                next_boss_phase = boss_template.get_phase(phase_num + 1)

            dp = generate_decision_point(
                phase_after=phase_num + 1,
                player_stability=metrics.stability,
                enemy_hp=enemy_hp,
                enemy_stability=enemy_stability,
                boss_phase=next_boss_phase,
            )
            decision_points.append(dp)

        # â”€â”€ Early termination: enemy or player defeated â”€â”€
        if enemy_hp <= 0:
            break
        if metrics.hp <= 0:
            # â”€â”€ Mid-combat Fate Buffer Save + Power Burst â”€â”€
            from app.engine.failure import (
                can_fate_save, FATE_SAVE_ADAPT_BONUS,
                FATE_BURST_HP_RESTORE_PCT, FATE_BURST_STABILITY_RESTORE,
                get_fate_save_narrative, get_fate_burst_directive,
            )
            if can_fate_save(fate_buffer):
                # Enhanced burst: restore 25% of starting HP + stability
                burst_hp = max(1.0, initial_hp * FATE_BURST_HP_RESTORE_PCT)
                metrics.hp = burst_hp
                metrics.stability = min(
                    100.0,
                    metrics.stability + FATE_BURST_STABILITY_RESTORE,
                )
                fate_fired = True
                # Deduct cost from local buffer
                fate_buffer = max(0.0, fate_buffer - 40.0)
                adapt_bonus += FATE_SAVE_ADAPT_BONUS

                # Narrative: lore-appropriate save + skill burst directive
                phase_result.narrative_cues.append(
                    get_fate_save_narrative(
                        getattr(metrics, '_defeat_count', 0)
                    )
                )
                phase_result.narrative_cues.append(
                    get_fate_burst_directive(
                        getattr(metrics, '_defeat_count', 0)
                    )
                )
                logger.info(
                    f"FATE BURST! HPâ†’{burst_hp:.0f} (25% of {initial_hp:.0f}), "
                    f"stability+{FATE_BURST_STABILITY_RESTORE}, "
                    f"adapt+{FATE_SAVE_ADAPT_BONUS}"
                )
                # Combat continues!
            else:
                break

    # â”€â”€ Determine final outcome â”€â”€
    if metrics.hp <= 0:
        final_outcome = "enemy_wins"
    elif enemy_hp <= 0:
        final_outcome = "player_wins"
    else:
        # Based on majority of phase outcomes
        favorable_count = sum(
            1 for p in phase_results if p.outcome == "favorable"
        )
        unfavorable_count = sum(
            1 for p in phase_results if p.outcome == "unfavorable"
        )
        if favorable_count > unfavorable_count:
            final_outcome = "player_wins"
        elif unfavorable_count > favorable_count:
            final_outcome = "enemy_wins"
        else:
            final_outcome = "draw"

    # â”€â”€ Compute identity impact â”€â”€
    instability_gained = max(0.0, metrics.instability - initial_instability)

    # â”€â”€ Build narrative consequences â”€â”€
    consequences: list[str] = []
    if final_outcome == "player_wins":
        consequences.append(f"Chiáº¿n tháº¯ng {enemy.name}")
        if encounter_type in (EncounterType.BOSS, EncounterType.CLIMAX):
            consequences.append("Boss bá»‹ háº¡ â€” má»Ÿ Ä‘Æ°á»ng tiáº¿n")
    elif final_outcome == "enemy_wins":
        consequences.append(f"Tháº¥t báº¡i trÆ°á»›c {enemy.name}")
        consequences.append("Cáº§n há»“i phá»¥c trÆ°á»›c khi tiáº¿p tá»¥c")
    else:
        consequences.append(f"Tráº­n Ä‘áº¥u báº¥t phÃ¢n vá»›i {enemy.name}")

    # â”€â”€ Determine floor progress â”€â”€
    floor_progress = (
        final_outcome == "player_wins"
        and encounter_type in (EncounterType.BOSS, EncounterType.CLIMAX)
    )

    # â”€â”€ Build CombatBriefV2 â”€â”€
    return CombatBriefV2(
        encounter_type=encounter_type.value,
        enemy_name=enemy.name,
        enemy_type=boss_template.enemy_type if boss_template else "",
        enemy_description=enemy.description,
        enemy_principle=enemy.principle,
        boss_id=boss_template.boss_id if boss_template else None,
        boss_template_name=boss_template.name if boss_template else "",
        phases=phase_results,
        decision_points=decision_points,
        current_phase=len(phase_results),
        total_phases=total_phases,
        is_complete=True,
        final_outcome=final_outcome,
        player_state_after={
            "hp": round(metrics.hp, 1),
            "stability": round(metrics.stability, 1),
            "instability": round(metrics.instability, 1),
        },
        total_stability_cost=round(total_stability_cost, 1),
        total_hp_cost=round(total_hp_cost, 1),
        resonance_growth=0.0,  # Accumulated in apply_combat_results
        resonance_principle=skill.primary_principle or "",
        instability_gained=round(instability_gained, 1),
        narrative_consequences=consequences,
        floor_progress=floor_progress,
        player_skill_name=skill.name,
        player_skill_mechanic=skill.mechanic,
        player_principle=skill.primary_principle or "",
        unique_skill_active=unique_skill_bonus > 0,
        principle_advantage=interaction.interaction.value,
        fate_fired=fate_fired,
    )


def build_combat_result(brief: CombatBriefV2) -> CombatResult:
    """Convert a completed CombatBriefV2 into CombatResult for IdentityDelta.

    Â§11: Maps combat outcome to identity system changes.
    """
    # DQS change based on decision quality
    dqs_base = 0.0
    for phase in brief.phases:
        if phase.outcome == "favorable":
            dqs_base += 2.0
        elif phase.outcome == "mixed":
            dqs_base += 0.5
        else:
            dqs_base -= 1.0

    # Coherence: fighting aligned with build = coherence boost
    coherence = 1.0 if brief.final_outcome == "player_wins" else -1.0

    # Breakthrough: high-risk combat â†’  breakthrough meter
    breakthrough = 0.0
    for phase in brief.phases:
        if phase.intensity_used == "overdrive":
            breakthrough += 5.0
        elif phase.intensity_used == "push":
            breakthrough += 2.0

    return CombatResult(
        winner=_outcome_to_winner(brief.final_outcome),
        encounter_type=brief.encounter_type,
        decision_count=len(brief.decision_points),
        hp_remaining=brief.player_state_after.get("hp", 100.0),
        stability_remaining=brief.player_state_after.get("stability", 100.0),
        instability_gained=brief.instability_gained,
        dqs_change=round(dqs_base, 1),
        coherence_change=round(coherence, 1),
        breakthrough_change=round(breakthrough, 1),
        narrative_consequences=brief.narrative_consequences,
        floor_progress=brief.floor_progress,
    )


def _outcome_to_winner(outcome: str) -> str:
    """Map final outcome string to winner string."""
    mapping = {
        "player_wins": "player",
        "enemy_wins": "enemy",
        "draw": "draw",
        "fate_save": "fate_buffer_save",
    }
    return mapping.get(outcome, "draw")


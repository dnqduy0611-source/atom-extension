"""Tests generated by AMO Test Pilot for consequence_router.py and related models.

Covers:
  - CausalChain, FactionImplication, WriterGuidance, ConsequenceRouterOutput models
  - Context envelope builder
  - Output parsing and fallback
  - Pipeline ledger wiring (faction_implications → villain_tracker)
  - Context.py injection (causal chains + writer guidance)
"""
import pytest
from pydantic import ValidationError

from app.models.pipeline import (
    CausalChain,
    ConsequenceRouterOutput,
    FactionImplication,
    NarrativeState,
    SimulatorOutput,
    WriterGuidance,
)
from app.narrative.consequence_router import (
    _build_context_envelope,
    _extract_json,
)


# ──────────────────────────────────────────────
# Model tests
# ──────────────────────────────────────────────

class TestCausalChain:
    def test_defaults(self):
        c = CausalChain()
        assert c.id == ""
        assert c.links == []
        assert c.horizon == "immediate"
        assert c.reversible is True
        assert c.cascade_risk == "low"
        assert c.unique_skill_triggered is False
        assert c.faction_involved == ""

    def test_full_chain(self):
        c = CausalChain(
            id="chain_001",
            trigger="Player betrays IronVeil",
            links=["IronVeil loses asset", "Bounty placed", "Crimson gains leverage"],
            horizon="immediate_to_long_term",
            reversible=False,
            cascade_risk="high",
            unique_skill_triggered=True,
            faction_involved="IronVeil",
        )
        assert len(c.links) == 3
        assert c.cascade_risk == "high"


class TestFactionImplication:
    def test_defaults(self):
        fi = FactionImplication()
        assert fi.notoriety_contribution == 0.0
        assert fi.empire_resonance_delta == 0
        assert fi.identity_anchor_delta == 0

    def test_empire_deltas(self):
        fi = FactionImplication(
            faction="Empire",
            stance_change="neutral → hostile",
            empire_resonance_delta=10,
            identity_anchor_delta=-5,
        )
        assert fi.empire_resonance_delta == 10
        assert fi.identity_anchor_delta == -5


class TestWriterGuidance:
    def test_defaults(self):
        wg = WriterGuidance()
        assert wg.tone == "neutral"
        assert wg.highlight_chains == []
        assert wg.pacing_note == ""

    def test_full(self):
        wg = WriterGuidance(
            tone="tense",
            highlight_chains=["chain_001"],
            foreshadow_priority="revenge arc",
            unique_skill_narrative_note="Contract should feel binding",
            pacing_note="fast_escalation",
        )
        assert wg.tone == "tense"
        assert len(wg.highlight_chains) == 1


class TestConsequenceRouterOutput:
    def test_defaults(self):
        out = ConsequenceRouterOutput()
        assert out.causal_chains == []
        assert out.faction_implications == []
        assert isinstance(out.writer_guidance, WriterGuidance)
        # Backward compat fields
        assert out.consequences == []
        assert out.relationship_changes == []
        assert out.foreshadowing == []
        assert out.world_impact == ""

    def test_world_impact_none_coerced(self):
        out = ConsequenceRouterOutput(world_impact=None)
        assert out.world_impact == ""

    def test_full_output(self):
        out = ConsequenceRouterOutput(
            causal_chains=[CausalChain(id="c1", trigger="test", links=["a", "b"])],
            faction_implications=[FactionImplication(faction="X")],
            writer_guidance=WriterGuidance(tone="tense"),
            consequences=[{"description": "test", "severity": "major"}],
            foreshadowing=["hint 1"],
            identity_alignment={"aligns_with_seed": True, "drift_indicator": "minor"},
        )
        assert len(out.causal_chains) == 1
        assert out.causal_chains[0].links == ["a", "b"]
        assert out.faction_implications[0].faction == "X"
        assert out.writer_guidance.tone == "tense"
        assert out.identity_alignment["drift_indicator"] == "minor"

    def test_backward_compat_with_simulator(self):
        """ConsequenceRouterOutput should have all SimulatorOutput fields."""
        sim_fields = set(SimulatorOutput.model_fields.keys())
        cr_fields = set(ConsequenceRouterOutput.model_fields.keys())
        assert sim_fields.issubset(cr_fields), f"Missing: {sim_fields - cr_fields}"


# ──────────────────────────────────────────────
# Context envelope builder
# ──────────────────────────────────────────────

class TestBuildContextEnvelope:
    def test_minimal_state(self):
        state = NarrativeState()
        result = _build_context_envelope(state)
        assert "Bắt đầu" in result  # default choice
        assert "risk level: 1" in result
        assert "Đây là chương đầu tiên" in result

    def test_with_previous_summary(self):
        state = NarrativeState(previous_summary="Player defeated Vorn")
        result = _build_context_envelope(state)
        assert "Player defeated Vorn" in result
        assert "Đây là chương đầu tiên" not in result

    def test_with_action_category(self):
        state = NarrativeState(action_category="combat", skill_reference="Shadow Cut")
        result = _build_context_envelope(state)
        assert "combat" in result
        assert "Shadow Cut" in result

    def test_with_villain_context(self):
        state = NarrativeState(villain_context="Empire resonance: RẤT CAO")
        result = _build_context_envelope(state)
        assert "Villain Context" in result
        assert "RẤT CAO" in result

    def test_with_player_intent(self):
        state = NarrativeState(player_intent="Muốn đổi phe")
        result = _build_context_envelope(state)
        assert "Muốn đổi phe" in result

    def test_identity_coherence_included(self):
        state = NarrativeState(player_state={"identity_coherence": 42.5})
        result = _build_context_envelope(state)
        assert "42.5" in result

    def test_with_dict_player(self):
        state = NarrativeState(
            player_state={
                "archetype": "tactician",
                "notoriety": 30.0,
                "alignment": -10.0,
                "current_identity": {
                    "active_values": ["loyalty", "honor"],
                    "active_traits": ["cautious"],
                },
            }
        )
        result = _build_context_envelope(state)
        assert "tactician" in result
        assert "loyalty" in result
        assert "honor" in result
        assert "cautious" in result


# ──────────────────────────────────────────────
# JSON extraction
# ──────────────────────────────────────────────

class TestExtractJson:
    def test_plain_json(self):
        assert _extract_json('{"a": 1}') == '{"a": 1}'

    def test_markdown_fenced(self):
        text = "```json\n{\"a\": 1}\n```"
        assert _extract_json(text) == '{"a": 1}'

    def test_whitespace(self):
        assert _extract_json("  {\"a\": 1}  ") == '{"a": 1}'


# ──────────────────────────────────────────────
# Pipeline integration: drift_indicator mapping
# ──────────────────────────────────────────────

class TestDriftIndicatorMapping:
    """Verify the drift → identity_anchor_delta mapping per spec §12."""

    def test_drift_deltas(self):
        mapping = {"none": 0, "minor": -3, "significant": -8, "critical": -15}
        assert mapping["none"] == 0
        assert mapping["minor"] == -3
        assert mapping["significant"] == -8
        assert mapping["critical"] == -15

    def test_unknown_drift_defaults_to_0(self):
        mapping = {"none": 0, "minor": -3, "significant": -8, "critical": -15}
        assert mapping.get("unknown_value", 0) == 0


# ──────────────────────────────────────────────
# NarrativeState consequence_output field
# ──────────────────────────────────────────────

class TestNarrativeStateFields:
    def test_has_consequence_output_field(self):
        state = NarrativeState()
        assert hasattr(state, "consequence_output")
        assert state.consequence_output is None

    def test_consequence_output_accepts_model(self):
        out = ConsequenceRouterOutput(
            causal_chains=[CausalChain(id="c1")],
        )
        state = NarrativeState(consequence_output=out)
        assert state.consequence_output.causal_chains[0].id == "c1"

    def test_simulator_output_still_works(self):
        sim = SimulatorOutput(consequences=[{"desc": "test"}])
        state = NarrativeState(simulator_output=sim)
        assert len(state.simulator_output.consequences) == 1


# ──────────────────────────────────────────────
# Prompt file exists
# ──────────────────────────────────────────────

class TestPromptFile:
    def test_consequence_router_prompt_exists(self):
        from pathlib import Path
        prompt = Path("app/prompts/consequence_router.md")
        assert prompt.exists(), "consequence_router.md prompt file missing"

    def test_prompt_contains_chain_rules(self):
        from pathlib import Path
        content = Path("app/prompts/consequence_router.md").read_text(encoding="utf-8")
        assert "causal_chains" in content
        assert "faction_implications" in content
        assert "writer_guidance" in content
        assert "cascade_risk" in content
        assert "Rule 1" in content
        assert "Rule 2" in content

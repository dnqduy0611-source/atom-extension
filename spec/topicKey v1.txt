Dưới đây là **định nghĩa topicKey v1** đúng tinh thần bạn chốt: **ưu tiên tag user-confirm → fallback domain → fallback title keywords**, thiết kế để **ổn định, ít loạn cluster, không cần LLM**, chạy ngon trong MV3.

---

# 1) Mục tiêu của `topicKey` (v1)

`topicKey` là **khóa nhóm (cluster key)** để gom các ReadingBundle thành “cùng một chủ đề” phục vụ:

* Idea Incubator trigger
* routing sang NotebookLM notebook
* thống kê/recall

**Yêu cầu:**

* ổn định theo thời gian
* chống spam (không tạo ra quá nhiều key)
* không cần NLP nặng

---

# 2) Input tối thiểu (từ ReadingBundle)

V1 chỉ cần:

* `tags[]` (có flag user-confirm)
* `domain`
* `title` (hoặc `document.title`)
* (optional) `url` để fallback cuối

Bạn nên chuẩn hoá sẵn:

* `domainNormalized` (bỏ www, lowercase)
* `titleNormalized` (lowercase, remove punctuation)

---

# 3) Định nghĩa **3 tầng topicKey** (Priority)

## Tầng A — Tag user-confirm (ưu tiên cao nhất)

### Khi dùng

Nếu bundle có ≥ 1 tag được user confirm (không phải tag AI gợi ý “chưa confirm”).

### Cách tạo key

* Chọn 1 “primaryTag” theo thứ tự:

  1. tag user tự nhập
  2. tag user tick confirm từ gợi ý
* Chuẩn hoá tag:

  * lowercase
  * bỏ dấu tiếng Việt (tuỳ bạn, khuyến nghị có)
  * thay khoảng trắng bằng `-`
  * bỏ ký tự lạ

✅ `topicKey = "tag:" + slug(primaryTag)`

**Ví dụ:**

* `#DBS STN` → `tag:dbs-stn`
* `#atom-design` → `tag:atom-design`

> Lưu ý: v1 **chỉ dùng 1 tag primary** để tránh bùng nổ tổ hợp. (v1.2 mới tính multi-tag)

---

## Tầng B — Domain (fallback thứ 2)

### Khi dùng

Không có tag user-confirm.

### Cách tạo key

✅ `topicKey = "dom:" + registrableDomain(domain)`

Trong đó `registrableDomain` nghĩa là:

* `news.ycombinator.com` → `ycombinator.com`
* `scholar.google.com` → `google.com`
* `pubmed.ncbi.nlm.nih.gov` → `ncbi.nlm.nih.gov`

**Ví dụ:**

* PubMed: `dom:ncbi.nlm.nih.gov`
* AAO: `dom:aao.org`

> Nếu bạn không muốn viết parser PSL (public suffix list) v1, có thể dùng heuristic: lấy 2–3 label cuối, nhưng nhớ edge case `.co.uk`.
> Mình khuyến nghị v1 dùng heuristic đơn giản + allow override (options) cho domain đặc biệt.

---

## Tầng C — Title keywords (fallback thứ 3, ổn định vừa đủ)

### Khi dùng

Không có tag user-confirm và domain thuộc nhóm “rộng” (google.com, youtube.com, facebook.com, reddit.com, x.com…) **hoặc** title mang tính chủ đề rõ hơn domain.

### Ý tưởng v1: “keyword fingerprint” cực nhẹ

1. `titleNormalized`
2. tokenize theo space
3. loại stopwords (EN + VI cơ bản)
4. loại token quá ngắn (<3)
5. loại token dạng số/ID
6. lấy top **K=3** token theo:

   * ưu tiên token dài hơn
   * ưu tiên token xuất hiện trong title gần đầu
7. sắp xếp token theo alphabet để ổn định
8. join bằng `-`

✅ `topicKey = "kw:" + t1 + "-" + t2 + "-" + t3`

**Ví dụ:**

* “OSS-DBSv2 electric field VTA modeling”
  → tokens: oss-dbs, vta, modeling
  → `kw:modeling-oss-dbs-vta` (hoặc `kw:oss-dbs-modeling-vta` tuỳ rule)

* “Subthalamic nucleus fiber tract stimulation tremor”
  → `kw:fiber-stimulation-subthalamic`

### Khi nào nên kích hoạt keyword thay vì domain?

Đặt 1 danh sách `broadDomains`:

* `google.com`, `youtube.com`, `facebook.com`, `x.com`, `reddit.com`, `wikipedia.org`, `github.com`…
  Nếu domain thuộc broadDomains → ưu tiên keyword.

---

# 4) Quy tắc “giảm loạn cluster” (anti-fragmentation)

## Rule 1 — Canonicalization tags

Tạo alias map nhỏ:

* `dbs`, `deep-brain-stimulation` → `dbs`
* `atom`, `atom-extension` → `atom`

=> `tag:dbs` gom được nhiều.

## Rule 2 — Keyword bucket by domain

Nếu domain là `youtube.com` hoặc `github.com`, keyword rất đa dạng.
Bạn nên thêm “bucket prefix”:

* YouTube: `kw:yt-<fingerprint>`
* GitHub: `kw:gh-<fingerprint>`

## Rule 3 — Minimum confidence để dùng keyword

Chỉ tạo keyword topic khi:

* title có ≥ 3 keyword hợp lệ
* hoặc engagementScore cao (vd ≥2)

Nếu không đủ, fallback về domain để tránh tạo key “kw:undefined”.

---

# 5) Pseudocode (để Codex implement nhanh)

```js
function computeTopicKey(bundle, opts) {
  const tags = getUserConfirmedTags(bundle.tags);
  if (tags.length) {
    const primary = pickPrimaryTag(tags);
    return `tag:${slug(primary)}`;
  }

  const dom = registrableDomain(bundle.domain);
  if (!dom) return "dom:unknown";

  if (opts.broadDomains.includes(dom)) {
    const fp = keywordFingerprint(bundle.title, opts);
    if (fp) return `kw:${opts.domainPrefixMap?.[dom] ?? ""}${fp}`;
  }

  // default domain
  return `dom:${dom}`;
}
```

---

# 6) Output format chuẩn v1 (để dễ debug/analytics)

* `topicKey`: string như `tag:xxx`, `dom:xxx`, `kw:xxx`
* `topicSource`: enum `"tag"|"domain"|"keyword"`
* `topicLabel`: human readable:

  * tag → “#dbs-stn”
  * domain → “ncbi.nlm.nih.gov”
  * keyword → “fiber stimulation subthalamic”

---

# 7) Default stopwords (v1 tối giản)

Không cần hoàn hảo. Chỉ cần loại từ rác phổ biến.

**EN:** the, a, an, of, to, and, or, in, for, with, on, by, from, at, as, is, are
**VI:** là, và, của, cho, với, trong, một, các, những, từ, về, ở, theo, khi, như

---

# 8) Khuyến nghị cấu hình options (để user tự “đúng hoá” topicKey)

Trong options:

* `broadDomains[]` (editable)
* `tagAliases{}` (editable)
* `domainPrefixMap{}` (optional)
* toggle: “Prefer keyword for broad domains” (default ON)

---

Nếu bạn muốn, mình có thể viết luôn **spec mini cho topicKey + test cases** (10–20 case) để Codex chạy unit test, đảm bảo không loạn cluster ngay từ v1.

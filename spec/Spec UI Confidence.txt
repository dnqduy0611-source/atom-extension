Dưới đây là **Spec UI Confidence (Dev Panel)** dạng “đưa thẳng cho dev implement”, viết rõ **mục tiêu – data contract – luồng – UI – acceptance criteria – non-functional** theo đúng MV3.

---

# ATOM – UI Confidence Dev Panel Spec (v1)

## 0) Mục tiêu

Tạo **Dev Panel** trong **Options Page** (ưu tiên) để dev/user kỹ thuật có thể:

1. **Xem realtime** AI đang trả `label` gì và `confidence` bao nhiêu.
2. Biết quyết định cuối cùng **AI được dùng hay fallback** (do dưới ngưỡng / timeout / error).
3. Xem **history gần nhất (ring buffer)** để debug prompt/threshold nhanh, không cần mở log rời rạc.

> Panel này phục vụ **debug & tuning** (minConfidence, prompt, timeout), không phải UI cho end-user.

---

## 1) Phạm vi (Scope)

### In-scope

* Hiển thị **Latest event** + **History list (tối đa 50)**.
* Có **realtime stream** event từ background (MV3 service worker).
* Có **tab filter**: xem global hoặc theo `tabId`.
* Nút **Refresh** (pull snapshot) + **Clear** (clear view trên UI, không cần xóa trong background v1).
* Toggle **Realtime ON/OFF**.

### Out-of-scope (v1)

* Không cần chart/histogram confidence.
* Không cần export file.
* Không cần xóa ring buffer trong background (v2 có thể thêm).
* Không cần hiển thị full prompt/selected text (tránh privacy & nặng).

---

## 2) Định nghĩa thuật ngữ

* **Confidence**: số 0–1 do AI trả về (self-rated) hoặc do hệ thống map ra.
* **minConfidence**: ngưỡng cấu hình (mặc định 0.65). AI chỉ được dùng nếu `confidence >= minConfidence`.
* **usedAI**: boolean, biểu thị quyết định cuối cùng có sử dụng kết quả AI hay không.
* **fallback**: quyết định không dùng AI và chuyển sang heuristic/rule-based do `below_threshold | timeout | error | disabled | budget_exceeded`.

---

## 3) Kiến trúc tổng quan (MV3)

### Thành phần

1. **Producers**: nơi phát event (ai_service.js, strategy_layer.js, core_logic.js…).
2. **Debug Hub (background service worker)**:

   * Nhận event qua `chrome.runtime.onMessage`
   * Lưu ring buffer global + per-tab
   * Broadcast realtime qua `chrome.runtime.onConnect` port
3. **Options UI Dev Panel**:

   * Pull snapshot (`ATOM_DEBUG_GET_STATE`)
   * Subscribe realtime port (`ATOM_DEBUG_PORT`)
   * Render Latest + History + controls

---

## 4) Data Contract (schema event)

Mọi event debug gửi về hub phải theo format:

```ts
type AtomDebugEvent = {
  ts?: number;              // epoch ms, nếu không có hub tự add
  tabId?: number;           // nếu producer biết; nếu không hub lấy từ sender.tab.id
  url?: string;             // optional (khuyến nghị, để debug site)
  kind: string;             // "ai_decision" | "ai_timeout" | "ai_error" | "fallback" | ...
  label?: string;           // e.g. "doomscroll", "reading"
  confidence?: number;      // 0..1
  minConfidence?: number;   // current threshold
  usedAI?: boolean;         // true if AI result used
  reason?: string;          // "pass_threshold" | "below_threshold" | "timeout_fallback" | ...
  model?: string;           // e.g. "gemini-..." (optional)
  latencyMs?: number;       // optional
  meta?: Record<string, any>; // optional, giới hạn nhỏ, không chứa text dài
}
```

### Rules

* `confidence` nếu có phải nằm trong [0,1].
* `label` nên là 1 enum của pipeline (doomscroll/reading/idle/unknown…).
* `reason` bắt buộc khi `usedAI === false` để biết vì sao fallback.
* `meta` không chứa prompt, không chứa selected text (để tránh lộ dữ liệu & nặng).

---

## 5) Message/Port Protocol (Background ↔ UI)

### 5.1 Push event (Producer → Background)

Producer gửi:

```js
chrome.runtime.sendMessage({
  type: "ATOM_DEBUG_PUSH",
  payload: AtomDebugEvent
})
```

Background phản hồi:

```js
{ ok: true }
```

### 5.2 Pull snapshot (UI → Background)

UI gửi:

```js
chrome.runtime.sendMessage({
  type: "ATOM_DEBUG_GET_STATE",
  tabId?: number | null
})
```

Background trả:

```ts
{
  ok: true,
  enabled: boolean,
  maxEvents: number,
  events: AtomDebugEvent[],     // global ring buffer
  tabEvents: AtomDebugEvent[]   // ring buffer theo tab nếu tabId được truyền
}
```

### 5.3 Realtime stream (UI ↔ Background)

UI mở port:

```js
chrome.runtime.connect({ name: "ATOM_DEBUG_PORT" })
```

Background gửi:

* Snapshot ban đầu:

```ts
{ type: "ATOM_DEBUG_SNAPSHOT", payload: { events: AtomDebugEvent[] } }
```

* Event realtime:

```ts
{ type: "ATOM_DEBUG_EVENT", payload: AtomDebugEvent }
```

---

## 6) Storage & Buffering (Background)

* `maxEvents` mặc định: **50**
* Lưu 2 buffer:

  1. `events[]`: global ring buffer
  2. `byTab: Map<tabId, events[]>`: per-tab ring buffer
* Khi push:

  * add `ts` nếu thiếu
  * add `tabId` từ `sender.tab.id` nếu thiếu
  * truncate theo `maxEvents`

---

## 7) UI/UX Spec (Options Page)

### 7.1 Layout

Một section “**Dev Panel – AI Confidence**” gồm:

**Header row**

* Title + subtitle
* Controls:

  * Checkbox: `Realtime` (default ON)
  * Button: `Refresh`
  * Button: `Clear`

**Grid row**

* Card trái: `Latest` (render JSON pretty)
* Card phải: `Tab Filter`

  * Input `tabId` (optional)
  * Button `Load Tab`
  * Hint: để trống xem global

**History**

* Title “History (max 50)”
* Status text: “N events”
* List items (reverse chronological)

### 7.2 History item format (1 dòng chính + 1 dòng phụ)

* Main:

  * `kind • label` + badge `✅ AI` hoặc `⬇️ fallback`
  * Timestamp (local time)
* Sub:

  * `tab:ID` (nếu có)
  * `confidence: x.xxx` (nếu có)
  * `threshold: y.yyy` (nếu có)
  * `reason` (nếu có)

### 7.3 Behavior

* Khi mở Options:

  * UI gọi `GET_STATE` để render initial list
  * UI connect Port nếu realtime ON
* Realtime ON:

  * Nhận `ATOM_DEBUG_EVENT` → apply filter tabId (nếu có) → push vào view buffer (max 50) → re-render
* Realtime OFF:

  * không connect port / disconnect port
  * chỉ xem snapshot qua Refresh
* Clear:

  * clear **view buffer** (UI) ngay lập tức
  * (v1) không bắt buộc clear background buffer
* Load Tab:

  * set `tabId filter` rồi gọi `GET_STATE(tabId)` để load ring buffer theo tab

---

## 8) Event tối thiểu bắt buộc (MVP)

Dev phải đảm bảo bắn ít nhất các event sau:

1. **ai_decision**

* when: có response AI parse xong
* fields: `kind, label, confidence, minConfidence, usedAI, reason, model?, latencyMs?`

2. **ai_timeout**

* when: call AI quá `timeoutMs`
* fields: `kind="ai_timeout", usedAI=false, reason="timeout_fallback", timeoutMs`

3. **ai_error**

* when: exception / parse fail
* fields: `kind="ai_error", usedAI=false, reason="error_fallback", meta.errorMessage`

---

## 9) Acceptance Criteria (điều kiện nghiệm thu)

1. Mở Options → panel hiển thị history (dù rỗng cũng không crash).
2. Khi AI decision xảy ra, panel realtime update trong < 300ms (thường nhanh).
3. Nếu `confidence < minConfidence`:

   * item hiển thị `⬇️ fallback` + reason `below_threshold`
4. Nếu timeout:

   * item hiển thị `⬇️ fallback` + kind `ai_timeout`
5. Tab Filter:

   * nhập tabId → chỉ thấy events của tab đó.
6. Không làm lag browsing:

   * ring buffer max 50
   * không render text dài
   * event payload nhỏ

---

## 10) Non-functional Requirements

* **MV3-safe**: dùng service worker background + port connect.
* **Performance**: re-render list đơn giản, không dùng framework nặng.
* **Privacy**: không log nội dung trang/prompt/selected text; chỉ log metadata.
* **Stability**: nếu port disconnect (service worker sleep) UI tự reconnect khi user refresh hoặc toggle realtime.

---

## 11) V2 (gợi ý nâng cấp)

* Button “Copy JSON” / “Export” để gửi bug report.
* Histogram confidence theo label.
* “Clear background buffer” command.
* Toggle `ATOM_DEBUG.enabled` lưu trong `chrome.storage`.

---

Nếu bạn muốn, mình có thể viết luôn **Spec mapping từ pipeline**: “ở file nào, function nào nên bắn event” theo đúng codebase ATOM của bạn (ai_service.js / strategy_layer.js / intervention_manager.js…), để dev không phải tự đoán.

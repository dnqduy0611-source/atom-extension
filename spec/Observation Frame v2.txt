// ================================
// ATOM AI-Pilot: Observation Frame v2 (Lightweight, MV3-safe)
// Drop-in skeleton for content.js
// ================================

// --- Optional: config nhận từ background để bật/tắt thu thập snippet/actions ---
let __ATOM_AI_PILOT_CFG__ = {
  enabled: false,
  accuracyLevel: "balanced", // "balanced" | "high" (high = gửi viewport snippet + headings)
  maxViewportChars: 900,
  maxSelectedChars: 450
};

// Background có thể gửi message để bật pilot, tránh tốn CPU khi chưa dùng
chrome.runtime.onMessage.addListener((msg) => {
  if (msg?.type === "ATOM_AI_PILOT_CONFIG" && msg?.payload) {
    __ATOM_AI_PILOT_CFG__ = { ...__ATOM_AI_PILOT_CFG__, ...msg.payload };
  }
});

// ---------- 1) RollingWindow60: ring buffer 60 giây theo “bucket mỗi giây” ----------
function createRollingWindow60() {
  const N = 60;
  const stamp = new Int32Array(N).fill(-1);

  // Behavior buckets
  const scrollPx = new Int32Array(N);
  const scrollEvents = new Int16Array(N);
  const dirChanges = new Int16Array(N);
  const scrollBack = new Int16Array(N);

  // “Active second” bucket: có tương tác trong giây đó
  const activeSec = new Int8Array(N);

  // Action buckets
  const selectCount = new Int16Array(N);
  const copyCount = new Int16Array(N);
  const findCount = new Int16Array(N);
  const openLinkCount = new Int16Array(N);
  const backForwardCount = new Int16Array(N);
  const typingCount = new Int16Array(N);

  function ensureSec(sec) {
    const idx = sec % N;
    if (stamp[idx] !== sec) {
      stamp[idx] = sec;
      scrollPx[idx] = 0;
      scrollEvents[idx] = 0;
      dirChanges[idx] = 0;
      scrollBack[idx] = 0;
      activeSec[idx] = 0;

      selectCount[idx] = 0;
      copyCount[idx] = 0;
      findCount[idx] = 0;
      openLinkCount[idx] = 0;
      backForwardCount[idx] = 0;
      typingCount[idx] = 0;
    }
    return idx;
  }

  function markActive(nowMs) {
    const sec = (nowMs / 1000) | 0;
    const idx = ensureSec(sec);
    activeSec[idx] = 1;
  }

  function addScroll(nowMs, absDeltaPx) {
    const sec = (nowMs / 1000) | 0;
    const idx = ensureSec(sec);
    scrollPx[idx] += absDeltaPx;
    scrollEvents[idx] += 1;
    activeSec[idx] = 1;
  }

  function addDirChange(nowMs) {
    const sec = (nowMs / 1000) | 0;
    const idx = ensureSec(sec);
    dirChanges[idx] += 1;
    activeSec[idx] = 1;
  }

  function addScrollBack(nowMs) {
    const sec = (nowMs / 1000) | 0;
    const idx = ensureSec(sec);
    scrollBack[idx] += 1;
    activeSec[idx] = 1;
  }

  function addAction(nowMs, kind) {
    const sec = (nowMs / 1000) | 0;
    const idx = ensureSec(sec);
    activeSec[idx] = 1;

    switch (kind) {
      case "select": selectCount[idx] += 1; break;
      case "copy": copyCount[idx] += 1; break;
      case "find": findCount[idx] += 1; break;
      case "openLink": openLinkCount[idx] += 1; break;
      case "nav": backForwardCount[idx] += 1; break;
      case "typing": typingCount[idx] += 1; break;
    }
  }

  // Tổng hợp trong 60s gần nhất (O(60) = siêu nhẹ)
  function summarize(nowMs) {
    const nowSec = (nowMs / 1000) | 0;

    let totalScrollPx = 0;
    let totalScrollEvents = 0;
    let totalDirChanges = 0;
    let totalScrollBack = 0;

    let totalSelect = 0, totalCopy = 0, totalFind = 0;
    let totalOpenLink = 0, totalNav = 0, totalTyping = 0;

    let activeSeconds = 0;

    // continuous scroll streak (dựa trên “giây có scrollPx > 0”)
    let bestStreak = 0;
    let curStreak = 0;

    for (let s = nowSec - 59; s <= nowSec; s++) {
      const idx = s % N;
      if (stamp[idx] !== s) {
        // slot cũ/stale
        curStreak = 0;
        continue;
      }

      // active seconds
      if (activeSec[idx] === 1) activeSeconds += 1;

      const px = scrollPx[idx] | 0;
      totalScrollPx += px;
      totalScrollEvents += scrollEvents[idx] | 0;
      totalDirChanges += dirChanges[idx] | 0;
      totalScrollBack += scrollBack[idx] | 0;

      totalSelect += selectCount[idx] | 0;
      totalCopy += copyCount[idx] | 0;
      totalFind += findCount[idx] | 0;
      totalOpenLink += openLinkCount[idx] | 0;
      totalNav += backForwardCount[idx] | 0;
      totalTyping += typingCount[idx] | 0;

      if (px > 0) {
        curStreak += 1;
        if (curStreak > bestStreak) bestStreak = curStreak;
      } else {
        curStreak = 0;
      }
    }

    const idleSeconds = Math.max(0, 60 - activeSeconds);
    const scrollPxPerSec = totalScrollPx / 60;

    return {
      scrollPxTotal: totalScrollPx,
      scrollPxPerSec,
      continuousScrollSec: bestStreak,
      directionChanges: totalDirChanges,
      scrollBackEvents: totalScrollBack,
      idleSec: idleSeconds,

      actions: {
        selectCount: totalSelect,
        copyCount: totalCopy,
        findCount: totalFind,
        openLinkCount: totalOpenLink,
        backForwardCount: totalNav,
        typingCount: totalTyping
      }
    };
  }

  return {
    markActive,
    addScroll,
    addDirChange,
    addScrollBack,
    addAction,
    summarize
  };
}

// ---------- 2) Dwell samples (mean + p90) trong 60s ----------
function createDwellSampler(maxSamples = 160) {
  // ring buffer
  const tsArr = new Int32Array(maxSamples);
  const msArr = new Int32Array(maxSamples);
  let ptr = 0;
  let count = 0;

  function add(nowMs, dwellMs) {
    if (dwellMs < 250) return;       // bỏ dwell siêu ngắn (noise)
    if (dwellMs > 15000) return;     // bỏ dwell quá dài (thường là rời tab/idle)
    tsArr[ptr] = nowMs | 0;
    msArr[ptr] = dwellMs | 0;
    ptr = (ptr + 1) % maxSamples;
    count = Math.min(count + 1, maxSamples);
  }

  function summarize(nowMs, windowMs = 60000) {
    const cutoff = nowMs - windowMs;
    const samples = [];
    for (let i = 0; i < count; i++) {
      const t = tsArr[i];
      if (t >= cutoff) samples.push(msArr[i]);
    }
    if (samples.length === 0) return { dwellMeanMs: 0, dwellP90Ms: 0 };

    let sum = 0;
    for (const v of samples) sum += v;

    // p90: sort mảng nhỏ (<=160) — ok khi tick 5s
    samples.sort((a, b) => a - b);
    const p90Idx = Math.min(samples.length - 1, Math.floor(samples.length * 0.9));
    return {
      dwellMeanMs: Math.round(sum / samples.length),
      dwellP90Ms: samples[p90Idx] | 0
    };
  }

  return { add, summarize };
}

// ---------- 3) Snippet & Context collectors (nhẹ, không scan toàn DOM) ----------
function sanitizeText(s) {
  if (!s) return "";
  let t = String(s);

  // Remove excessive whitespace
  t = t.replace(/\s+/g, " ").trim();

  // Basic “sensitive-ish” masks (optional, đơn giản)
  // mask long digit sequences (e.g., potential card/ID); keep last 4
  t = t.replace(/\b(\d{8,})(\d{4})\b/g, "****$2");

  // Cut
  return t;
}

function isInsideAtomUI(el) {
  // ATOM UI root id trong content.js hiện là 'atom-extension-root'
  if (!el) return false;
  const root = document.getElementById("atom-extension-root");
  return !!(root && (el === root || root.contains(el)));
}

function pickReadableContainer(el) {
  if (!el) return null;
  // ưu tiên các container “đọc”
  return el.closest("article, main, section, p, li, div") || el;
}

function collectViewportText(maxChars = 900, ctx = {}) {
  try {
    // Nếu đang có overlay của ATOM (intervention) thì thường sendTick đã return,
    // nhưng cứ phòng hờ:
    const root = document.getElementById("atom-extension-root");

    // Nếu đang focus block / intervention active -> skip snippet để tránh lấy text từ UI
    if (ctx?.isFocusBlockActive || ctx?.isInterventionActive) return "";

    const points = [
      [window.innerWidth * 0.5, window.innerHeight * 0.33],
      [window.innerWidth * 0.5, window.innerHeight * 0.50],
      [window.innerWidth * 0.5, window.innerHeight * 0.67],
      [window.innerWidth * 0.25, window.innerHeight * 0.50],
      [window.innerWidth * 0.75, window.innerHeight * 0.50]
    ];

    const seen = new Set();
    let out = "";

    for (const [x, y] of points) {
      const el0 = document.elementFromPoint(x, y);
      if (!el0) continue;
      if (root && isInsideAtomUI(el0)) continue;

      const el = pickReadableContainer(el0);
      if (!el) continue;

      // tránh lấy text từ input/textarea/contenteditable
      if (el.closest("input, textarea, [contenteditable='true']")) continue;

      // lấy text nhanh: innerText có thể tốn hơn textContent, nhưng thường ổn với 5 element
      const raw = el.innerText || el.textContent || "";
      const txt = sanitizeText(raw);

      if (!txt || txt.length < 40) continue;

      // chống trùng: hash thô theo prefix
      const key = txt.slice(0, 60);
      if (seen.has(key)) continue;
      seen.add(key);

      // append có giới hạn
      const remain = maxChars - out.length;
      if (remain <= 0) break;

      out += (out ? " " : "") + txt.slice(0, remain);
    }

    return out.slice(0, maxChars);
  } catch {
    return "";
  }
}

function collectHeadingsSample(limit = 6) {
  try {
    const hs = Array.from(document.querySelectorAll("h1, h2, h3"))
      .slice(0, limit)
      .map(h => sanitizeText(h.textContent || ""))
      .filter(Boolean)
      .map(s => s.slice(0, 80));
    return hs;
  } catch {
    return [];
  }
}

function estimateWordCountApproxFast() {
  // rất nhẹ: ước lượng từ số <p> và độ dài title/headings
  try {
    const pCount = Math.min(80, document.querySelectorAll("p").length);
    // giả định trung bình 18 từ/p (chỉ để hint cho AI)
    return pCount * 18;
  } catch {
    return 0;
  }
}

function detectPageTypeLight(url) {
  const u = String(url || "");
  const host = location.hostname;

  // pdf
  if (u.endsWith(".pdf") || document.querySelector("embed[type='application/pdf'], object[type='application/pdf'], iframe[src*='.pdf']")) {
    return "pdf";
  }

  // video (heuristic)
  if (
    host.includes("youtube.com") ||
    host.includes("tiktok.com") ||
    host.includes("instagram.com") ||
    u.includes("/shorts") ||
    u.includes("watch")
  ) {
    return "video";
  }

  // article
  if (document.querySelector("article")) return "article";

  // feed/forum heuristics nhẹ
  const feedRole = document.querySelector("[role='feed']");
  if (feedRole) return "feed";

  // forum/thread: nhiều comment-like elements
  const commentLike = document.querySelectorAll("[id*='comment'], [class*='comment'], [data-comment]").length;
  if (commentLike > 10) return "forum";

  // feed: nhiều card link + text ngắn
  const aCount = document.links ? Math.min(document.links.length, 400) : 0;
  const pCount = document.querySelectorAll("p").length;
  if (aCount > 120 && pCount < 10) return "feed";

  return "unknown";
}

function isInfiniteScrollLikely() {
  // heuristic: trang rất dài + nhiều link/card
  try {
    const longPage = document.documentElement.scrollHeight > window.innerHeight * 6;
    const manyLinks = (document.links?.length || 0) > 150;
    return longPage && manyLinks;
  } catch {
    return false;
  }
}

function hasVideoLikely() {
  try {
    return !!document.querySelector("video, [class*='video'], [id*='video']");
  } catch {
    return false;
  }
}

// ---------- 4) Observation Tracker: gắn listeners + xuất frame ----------
function createObservationTracker() {
  const win60 = createRollingWindow60();
  const dwell = createDwellSampler(160);

  let lastScrollY = window.scrollY;
  let lastScrollTs = Date.now();
  let lastDir = 0; // -1 up, 1 down, 0 none
  let lastDownTs = 0;

  // store last selected text (truncated)
  let lastSelectedText = "";

  function recordGenericActivity(nowMs) {
    win60.markActive(nowMs);
  }

  function recordScroll(nowMs) {
    // signed delta
    const y = window.scrollY;
    const dy = y - lastScrollY;
    if (dy === 0) return;

    const absDy = Math.abs(dy);
    const dir = dy > 0 ? 1 : -1;

    // dwell sample: thời gian giữa 2 lần scroll event
    const dt = nowMs - lastScrollTs;
    // dt lớn thường là “đọc”; ghi sample để mean/p90
    dwell.add(nowMs, dt);

    // per-sec aggregates
    win60.addScroll(nowMs, absDy);

    // direction change?
    if (lastDir !== 0 && dir !== lastDir && absDy >= 18) {
      win60.addDirChange(nowMs);
    }

    // heuristic reread/scroll-back:
    // điều kiện: cuộn lên (dir=-1), và trước đó có cuộn xuống, và có 1 khoảng dừng đọc (dt >= 1200ms),
    // và cuộn lên đủ “có ý nghĩa” (>=120px)
    if (dir === -1 && absDy >= 120) {
      const timeSinceDown = nowMs - lastDownTs;
      if (timeSinceDown < 10000 && dt >= 1200) {
        win60.addScrollBack(nowMs);
      }
    }

    if (dir === 1) lastDownTs = nowMs;

    lastDir = dir;
    lastScrollY = y;
    lastScrollTs = nowMs;
  }

  function recordSelect(text) {
    const t = sanitizeText(text);
    if (t.length < 12) return;
    const nowMs = Date.now();
    win60.addAction(nowMs, "select");
    lastSelectedText = t.slice(0, __ATOM_AI_PILOT_CFG__.maxSelectedChars);
  }

  function recordCopy(textMaybe) {
    const nowMs = Date.now();
    win60.addAction(nowMs, "copy");
    if (textMaybe) {
      const t = sanitizeText(textMaybe);
      if (t.length >= 12) lastSelectedText = t.slice(0, __ATOM_AI_PILOT_CFG__.maxSelectedChars);
    }
  }

  function recordFind() {
    win60.addAction(Date.now(), "find");
  }

  function recordOpenLink() {
    win60.addAction(Date.now(), "openLink");
  }

  function recordNav() {
    win60.addAction(Date.now(), "nav");
  }

  function recordTyping() {
    win60.addAction(Date.now(), "typing");
  }

  function snapshotFrameV2({ includeSnippet = false, state = {}, ui = {} } = {}) {
    const nowMs = Date.now();
    const sum = win60.summarize(nowMs);
    const dwellSum = dwell.summarize(nowMs, 60000);

    const url = window.location.href;
    const title = sanitizeText(document.title || "");
    const lang = (document.documentElement.getAttribute("lang") || "").slice(0, 8) || "unknown";

    const pageType = detectPageTypeLight(url);
    const headings = includeSnippet ? collectHeadingsSample(6) : [];
    const viewportText = includeSnippet ? collectViewportText(__ATOM_AI_PILOT_CFG__.maxViewportChars, ui) : "";

    // refresh selected text at snapshot time (avoid stale)
    let selectedText = "";
    if (includeSnippet) {
      const sel = window.getSelection();
      const txt = sel ? sel.toString() : "";
      if (txt) {
        selectedText = sanitizeText(txt).slice(0, __ATOM_AI_PILOT_CFG__.maxSelectedChars);
        lastSelectedText = selectedText || lastSelectedText;
      } else {
        selectedText = lastSelectedText || "";
      }
    }

    const wordApprox = includeSnippet
      ? Math.round((viewportText.length / 5)) // rough
      : estimateWordCountApproxFast();

    return {
      v: 2,
      ts: nowMs,
      // tabId: background sẽ fill

      page: {
        url,
        domain: location.hostname,
        path: location.pathname || "",
        title: title.slice(0, 120),
        lang,
        pageType,
        isInfiniteScrollLikely: includeSnippet ? isInfiniteScrollLikely() : false,
        hasVideoLikely: includeSnippet ? hasVideoLikely() : false,
        wordCountApprox: wordApprox,
        headingSample: headings
      },

      snippet: {
        viewportText,
        viewportTextChars: viewportText.length,
        selectedText: includeSnippet ? (selectedText || "") : "",
        selectedTextChars: includeSnippet ? (selectedText?.length || 0) : 0
      },

      behavior_60s: {
        dwellMeanMs: dwellSum.dwellMeanMs,
        dwellP90Ms: dwellSum.dwellP90Ms,
        scrollPxTotal: sum.scrollPxTotal,
        scrollPxPerSec: sum.scrollPxPerSec,
        continuousScrollSec: sum.continuousScrollSec,
        directionChanges: sum.directionChanges,
        scrollBackEvents: sum.scrollBackEvents,
        idleSec: sum.idleSec
      },

      actions_60s: { ...sum.actions },

      state: {
        focusEnabled: state?.focusEnabled ?? null,
        focusPhase: state?.focusPhase ?? null,
        focusAllowRemainingSec: state?.focusAllowRemainingSec ?? null,
        atomSensitivity: state?.atomSensitivity ?? null,
        lastInterventionType: state?.lastInterventionType ?? null,
        lastInterventionAgoSec: state?.lastInterventionAgoSec ?? null,
        resistanceScore: state?.resistanceScore ?? null
      }
    };
  }

  function resetAll(reason = "manual") {
    // reset “local cached” things
    lastScrollY = window.scrollY;
    lastScrollTs = Date.now();
    lastDir = 0;
    lastDownTs = 0;
    lastSelectedText = "";
    // Rolling window tự “decay” theo stamp; không cần clear toàn bộ mảng để tránh cost.
    // Nếu muốn hard reset, có thể tạo tracker mới.
    console.log("[ATOM][obs_v2] resetAll:", reason);
  }

  // ----- Attach lightweight listeners -----
  // Scroll: passive + chỉ làm toán đơn giản
  window.addEventListener("scroll", () => recordScroll(Date.now()), { passive: true });

  // Generic activity: click/keydown/mousemove (mousemove nên throttle nhẹ)
  window.addEventListener("click", () => recordGenericActivity(Date.now()), true);
  window.addEventListener("keydown", () => recordGenericActivity(Date.now()), true);

  let lastMoveAt = 0;
  window.addEventListener("mousemove", () => {
    const now = Date.now();
    if (now - lastMoveAt > 800) { // throttle
      lastMoveAt = now;
      recordGenericActivity(now);
    }
  }, { passive: true });

  // Selection (debounce)
  let selTimer = null;
  document.addEventListener("selectionchange", () => {
    if (selTimer) clearTimeout(selTimer);
    selTimer = setTimeout(() => {
      const sel = window.getSelection();
      const txt = sel ? sel.toString() : "";
      if (txt) recordSelect(txt);
    }, 250);
  });

  // Copy
  document.addEventListener("copy", () => {
    const sel = window.getSelection();
    const txt = sel ? sel.toString() : "";
    recordCopy(txt);
  }, true);

  // Find (Ctrl/Meta+F)
  window.addEventListener("keydown", (e) => {
    const k = (e.key || "").toLowerCase();
    const isFind = (k === "f") && (e.ctrlKey || e.metaKey);
    if (isFind) recordFind();

    // typing: nếu đang gõ trong input/textarea/contenteditable
    const t = e.target;
    const isEditable =
      t && (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable);
    if (isEditable && e.key && e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
      recordTyping();
    }
  }, true);

  // Open link (capture) - bỏ click trên UI của ATOM
  document.addEventListener("click", (e) => {
    const path = e.composedPath ? e.composedPath() : [];
    if (path.some(isInsideAtomUI)) return;

    const a = e.target && e.target.closest ? e.target.closest("a[href]") : null;
    if (!a) return;
    // bỏ href rỗng / hash-only
    const href = a.getAttribute("href") || "";
    if (!href || href === "#" || href.startsWith("javascript:")) return;

    recordOpenLink();
  }, true);

  // Back/forward: popstate/hashchange
  window.addEventListener("popstate", () => recordNav());
  window.addEventListener("hashchange", () => recordNav());

  return {
    snapshotFrameV2,
    resetAll
  };
}

// ================================
// INTEGRATION POINTS (content.js)
// ================================

// 1) Tạo tracker 1 lần
const __ATOM_OBS_V2__ = createObservationTracker();

// 2) Nếu bạn có hàm reset session hiện tại (resetScrollSession), hãy gọi thêm:
//// __ATOM_OBS_V2__.resetAll("carry-over-reset");

// 3) Trong sendTick(), trước khi sendMessage, build frame:
//// const includeSnippet = __ATOM_AI_PILOT_CFG__.enabled && __ATOM_AI_PILOT_CFG__.accuracyLevel === "high";
//// const state = {
////   focusEnabled: atomFocusPhase !== null,
////   focusPhase: atomFocusPhase || null,
////   atomSensitivity: cachedSensitivity || null,
////   resistanceScore: latestResistanceScore || null
//// };
//// const ui = {
////   isFocusBlockActive,
////   isInterventionActive
//// };
//// const frame_v2 = __ATOM_OBS_V2__.snapshotFrameV2({ includeSnippet, state, ui });

// 4) Gửi kèm vào payload:
//// payload: { url, continuous_scroll_sec, scroll_px, frame_v2 }
